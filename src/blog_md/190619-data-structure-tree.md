## 树结构
<div class="postConcepts">术语</div>：

+ 一个树结构是由一系列称为节点(nodes)的实体构成，节点由*边*(edges)连接
+ 每个节点包含值，每个节点可能有或没有子节点
+ 第一个节点称为*根节点*(root)，树结构最后且没有子节点的节点称为*叶子节点*(leaves)
+ 树的**高度**是根节点*到叶子节点*所有路径中**最长**的路径
+ 节点的**深度**是该节点到根节点的路径

二叉树一个重要的特性是：
> 一个节点的值比该节点的**左**子节点(及其后代)的值要**大**，但比其**右**子节点(及其后代)的值要**小**

### 创建二叉树和插入节点
当创建二叉树时，遵循以下的步骤：
1. 新节点的值*大于*或*小于*当前节点？
2. 若新节点值*大于*当前节点值，新节点被分配到右边子树(subtree)，若当前节点没有右子节点，则使`currentNode.right_child = newNode`；若当前节点已有右子节点，则把右子节点移为当前节点，重新进行步骤1
3. 若新节点值*小于*当前节点值，新节点被分配到左边子树(subtree)，若当前节点没有左子节点，则使`currentNode.left_child = newNode`；若当前节点已有左子节点，则把左子节点移为当前节点，重新进行步骤1
4. 当新节点的值===当前节点值时，可考虑把新节点插在左边子树

### 树的遍历(traversal)
2种选择：

#### 深度优先搜索(Depth-First Search - DFS)
从根元素开始，逐步遍历完到每个分支，再回到上个父节点，继续该父节点下的另一个分支，有3种深度优先搜索的类型：
+ Pre-order: 从该节点开始，遍历左子节点，再到右子节点
+ In-order: 先遍历左子节点，再到自身(中间)，再到右子节点
+ Post-order: 先遍历左子节点，再到右子节点，再到自身(中间)

#### 广度优先搜索(Breadth-First Search - BFS)
逐层和按深度来遍历树：通过**队列**结构来执行BFS搜索：
1. 把根节点加入队列
2. 队列非空时，遍历
3. 获取队列中的第一个节点，打印
4. 把这个节点的子节点加入队列中，重复2,3,4

### 移除节点和重排树
3种情况：

#### 该节点为叶子节点(leaf node)
直接删除，无需重新整理树结构

#### 该节点有且只有一个子节点
此时需要使该节点的*父*节点指向该节点的*子*节点

#### 该节点有2个子节点
需要从该节点的右子节点(及其后代)开始，找到该节点右边子树所有节点中的**最小值**的子节点，把它代替要移除的节点