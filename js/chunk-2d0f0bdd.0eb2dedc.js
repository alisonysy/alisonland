(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0f0bdd"],{"9e50":function(e,t,s){"use strict";s.r(t);var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},_=[function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("section",[s("h2",[e._v("3. "),s("em",[e._v("state")]),e._v("和"),s("em",[e._v("props")]),e._v("的联系和区别")]),s("h4",[e._v("共同点")]),s("ul",[s("li",[s("em",[e._v("state")]),e._v("和"),s("em",[e._v("props")]),e._v("在react中都是JS对象。")]),s("li",[e._v("两者若其中之一发生改变，都能触发组件的渲染。")]),s("li",[s("blockquote",[s("p",[e._v("Both props and state are deterministic. If your Component generates different outputs for the same combination of props and state then you're doing something wrong.")])])])]),s("h4",[e._v("区别")]),s("ul",[s("li",[s("em",[e._v("props")]),e._v("是从"),s("strong",[e._v("外部")]),e._v("传入组件的，相当于组件对外的数据接口，而"),s("em",[e._v("state")]),e._v("是组件"),s("strong",[e._v("内部维护")]),e._v("的，相当于组件对内的数据接口。")]),s("li",[e._v("组件内部不能更改"),s("em",[e._v("props")]),e._v("，而可以直接通过"),s("code",{pre:!0},[e._v("setState()")]),e._v("更改"),s("em",[e._v("state")]),e._v("。")])]),s("h4",[e._v("联系")]),s("ul",[s("li",[e._v("每个组件的"),s("em",[e._v("state")]),e._v("是私有的，理论上说，其他组件不能获取也不能更改；如果希望把组件状态传递出去，就需要通过"),s("em",[e._v("props")]),e._v("传递给子组件。")]),s("li",[e._v("组件内部可以通过接收的"),s("em",[e._v("props")]),e._v("里的方法调用外部方法，由外部方法修改对应组件的状态"),s("em",[e._v("state")]),e._v("。")])]),s("h3",[e._v("关于"),s("em",[e._v("state")]),e._v("：无状态组件与状态组件")]),s("p",[s("em",[e._v("Stateless Component")]),e._v("－只有属性，没有状态，内部得逻辑都是根据"),s("em",[e._v("props")]),e._v("产生，因为没有副作用，容易维护和debug。\n"),s("em",[e._v("Stateful Component")]),e._v("－有属性和状态，他们负责数据处理、事件交互等各种副作用，然后把数据作为属性传递下去。")]),s("h2",[e._v("4. "),s("em",[e._v("context")]),e._v("的作用")]),s("p",[e._v("在react中，数据的传递需要从上往下一层一层通过"),s("em",[e._v("props")]),e._v("传递，而"),s("em",[e._v("context")]),e._v("能替代这一繁冗的办法。他让没有直接联系的组件内也能共享数据，无需明确地通过"),s("em",[e._v("props")]),e._v("来传。")]),s("p",[s("em",[e._v("context")]),e._v("主要应用场景是在不同的组件层级传递数据，例如主题、当前语言或登录后账号等，应该将其作为备用选项因为他会使组件复用变得困难。"),s("em",[e._v("注意")]),e._v("：如果单纯只想避免通过多层组件传递"),s("em",[e._v("props")]),e._v("，应该考虑组件组合模型"),s("strong",[e._v("component composition")]),e._v("。")]),s("h4",[e._v("Syntax:")]),s("ol",[s("li",[e._v("创建"),s("em",[e._v("Context")]),e._v("对象")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("const")]),e._v(" MyContext = React.createContext(defaultValue);\n")])]),s("p",[s("code",{pre:!0},[e._v("React.createContext()")]),e._v("创建一个"),s("em",[e._v("Context")]),e._v("对象，组件可以订阅这个对象，渲染时，react会从组件树里最近的"),s("em",[e._v("Provider")]),e._v("中读取到当前context的值。"),s("code",{pre:!0},[e._v("defaultValue")]),e._v("参数在一个组件从他的组件树上游找不到提供组件"),s("em",[e._v("Provider")]),e._v("时会起作用，但把"),s("code",{pre:!0},[e._v("undefined")]),e._v("设置为context的值并不能使消费组件使用"),s("code",{pre:!0},[e._v("defaultValue")]),e._v("。")]),s("ol",{attrs:{start:"2"}},[s("li",[e._v("创建context提供组件\n创建后，可通过每个"),s("em",[e._v("Context")]),e._v("对象的"),s("em",[e._v("Provider React component")]),e._v("让消费组件订阅"),s("em",[e._v("context")]),e._v("的变化：")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[e._v("<MyContext.Provider value={"),s("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("/* some value */")]),e._v("}>\n")])]),s("p",[s("em",[e._v("Provider")]),e._v("可以通过嵌套来覆盖上层的值。"),s("code",{pre:!0},[e._v("value")]),e._v("是否改变是通过"),s("code",{pre:!0},[e._v("Object.is")]),e._v("来判断。\n当一个"),s("em",[e._v("Provider")]),e._v("的值发生改变，其后代所有消费组件都会重新渲染。从"),s("em",[e._v("Provider")]),e._v("到消费组件的事件传递并不依赖"),s("code",{pre:!0},[e._v("shouldComponentUpdate")]),e._v("，所以即使上游组件阻止了更新，消费组件仍然能更新。")]),s("ol",{attrs:{start:"3"}},[s("li",[e._v("类组件接收context\n类组件有2种方法来接收新创建的context，\n第一种是把"),s("em",[e._v("Context")]),e._v("对象赋予类的"),s("code",{pre:!0},[e._v("contextType")]),e._v("属性：")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[s("span",{pre:!0,attrs:{class:"hljs-class"}},[s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("MyClass")]),e._v(" "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("extends")]),e._v(" "),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("React")]),e._v("."),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("Component")]),e._v(" ")]),e._v("{\n  componentDidMount() {\n    "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("let")]),e._v(" value = "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("this")]),e._v(".context;\n    "),s("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("/* perform a side-effect at mount using the value of MyContext */")]),e._v("\n  }\n  componentDidUpdate() {\n    "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("let")]),e._v(" value = "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("this")]),e._v(".context;\n    "),s("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("/* ... */")]),e._v("\n  }\n  componentWillUnmount() {\n    "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("let")]),e._v(" value = "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("this")]),e._v(".context;\n    "),s("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("/* ... */")]),e._v("\n  }\n  render() {\n    "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("let")]),e._v(" value = "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("this")]),e._v(".context;\n    "),s("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("/* render something based on the value of MyContext */")]),e._v("\n  }\n}\nMyClass.contextType = MyContext;\n")])]),s("p",[e._v("第二种是实验中的"),s("em",[e._v("public class fields")]),e._v("，通过在类组件内添加静态方法"),s("code",{pre:!0},[e._v("contextType")]),e._v("：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[s("span",{pre:!0,attrs:{class:"hljs-class"}},[s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("MyClass")]),e._v(" "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("extends")]),e._v(" "),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("React")]),e._v("."),s("span",{pre:!0,attrs:{class:"hljs-title"}},[e._v("Component")]),e._v(" ")]),e._v("{\n  "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("static")]),e._v(" contextType = MyContext;\n  render() {\n    "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("let")]),e._v(" value = "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("this")]),e._v(".context;\n    "),s("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("/* render something based on the value */")]),e._v("\n  }\n}\n")])]),s("p",[s("em",[e._v("render")]),e._v("函数和不同的"),s("em",[e._v("生命周期")]),e._v("都能通过"),s("code",{pre:!0},[e._v("this.context")]),e._v("获取最近的"),s("code",{pre:!0},[e._v("contextType")]),e._v("的当前值，即"),s("em",[e._v("Provider")]),e._v("提供的"),s("code",{pre:!0},[e._v("value")]),e._v("。")]),s("ol",{attrs:{start:"3"}},[s("li",[e._v("函数组件接收context\n函数组件不使用"),s("code",{pre:!0},[e._v("contextType")]),e._v("，而是在"),s("strong",[e._v("返回函数")]),e._v("的外面包裹一层"),s("code",{pre:!0},[e._v("Context.Consumer")]),e._v("：")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[e._v("<MyContext.Consumer>\n  {value => "),s("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("/* render something based on the context value */")]),e._v("}\n<"),s("span",{pre:!0,attrs:{class:"hljs-regexp"}},[e._v("/MyContext.Consumer>\n")])])]),s("p",[s("code",{pre:!0},[e._v("Context.Consumer")]),e._v("里需要函数作为子元素，接收当前的"),s("em",[e._v("context")]),e._v("的值作为参数，返回一个react元素。"),s("em",[e._v("context")]),e._v("的值会等于最接近的"),s("em",[e._v("Provider")]),e._v("提供的"),s("code",{pre:!0},[e._v("value")]),e._v("，若没有"),s("em",[e._v("Provider")]),e._v("，则使用"),s("code",{pre:!0},[e._v("defaultValue")]),e._v("。")])])}],r=s("2877"),n={},a=Object(r["a"])(n,v,_,!1,null,null,null);t["default"]=a.exports}}]);
//# sourceMappingURL=chunk-2d0f0bdd.0eb2dedc.js.map