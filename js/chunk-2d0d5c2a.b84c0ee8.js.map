{"version":3,"sources":["webpack:///./src/blog_md/290420-how-https-works.md?d165","webpack:///./src/blog_md/290420-how-https-works.md"],"names":["render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","_v","script","component","Object","componentNormalizer","__webpack_exports__"],"mappings":"uHAAA,IAAAA,EAAA,WAA0B,IAAAC,EAAAC,KAAaC,EAAAF,EAAAG,eAA0BH,EAAAI,MAAAC,GAAwB,OAAAL,EAAAM,GAAA,IACzFC,EAAA,YAAoC,IAAAP,EAAAC,KAAaC,EAAAF,EAAAG,eAA0BE,EAAAL,EAAAI,MAAAC,IAAAH,EAAwB,OAAAG,EAAA,WAAAA,EAAA,MAAAL,EAAAQ,GAAA,eAAAH,EAAA,KAAAL,EAAAQ,GAAA,6EAAAH,EAAA,MAAAA,EAAA,MAAAL,EAAAQ,GAAA,UAAAH,EAAA,MAAAL,EAAAQ,GAAA,QAAAR,EAAAQ,GAAA,gBAAAH,EAAA,MAAAL,EAAAQ,GAAA,MAAAH,EAAA,MAAAL,EAAAQ,GAAA,UAAAR,EAAAQ,GAAA,oBAAAH,EAAA,MAAAL,EAAAQ,GAAA,MAAAH,EAAA,MAAAL,EAAAQ,GAAA,UAAAR,EAAAQ,GAAA,gBAAAH,EAAA,MAAAL,EAAAQ,GAAA,QAAAH,EAAA,MAAAA,EAAA,MAAAL,EAAAQ,GAAA,eAAAH,EAAA,MAAAL,EAAAQ,GAAA,gCAAAH,EAAA,MAAAL,EAAAQ,GAAA,0CAAAH,EAAA,MAAAL,EAAAQ,GAAA,6CAAAH,EAAA,MAAAL,EAAAQ,GAAA,6BAAAH,EAAA,MAAAL,EAAAQ,GAAA,0BAAAH,EAAA,MAAAL,EAAAQ,GAAA,UAAAH,EAAA,KAAAL,EAAAQ,GAAA,kIAAAH,EAAA,MAAAL,EAAAQ,GAAA,UAAAH,EAAA,KAAAL,EAAAQ,GAAA,+FAAAH,EAAA,MAAAL,EAAAQ,GAAA,UAAAR,EAAAQ,GAAA,iHCAnGC,EAAA,GAKAC,EAAgBC,OAAAC,EAAA,KAAAD,CAChBF,EACEV,EACAQ,GACF,EACA,KACA,KACA,MAIeM,EAAA,WAAAH","file":"js/chunk-2d0d5c2a.b84c0ee8.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',[_c('h2',[_vm._v(\"HTTPS工作原理\")]),_c('p',[_vm._v(\"HTTP是明文传输，容易被监听(eavesdropping)、被篡改(tampering)和被冒充(pretending)，而HTTPS能够：\")]),_c('ol',[_c('li',[_vm._v(\"所有信息都是\"),_c('em',[_vm._v(\"加密\")]),_vm._v(\"传播，第三方无法窃听\")]),_c('li',[_vm._v(\"具有\"),_c('em',[_vm._v(\"校验机制\")]),_vm._v(\"，一旦被篡改，通信双方会发现\")]),_c('li',[_vm._v(\"配备\"),_c('em',[_vm._v(\"身份证书\")]),_vm._v(\"，防止身份被冒充\")])]),_c('h3',[_vm._v(\"流程\")]),_c('ol',[_c('li',[_vm._v(\"客户端发出资源请求\")]),_c('li',[_vm._v(\"服务端返回有CA签名的证书，里面包含服务器生成的公钥\")]),_c('li',[_vm._v(\"客户端有CA的公钥，利用CA的公钥验证服务器返回的证书是否是CA签名过的\")]),_c('li',[_vm._v(\"确认是CA签名后，客户端创建一串随机数作为密钥，然后用服务端传来的公钥对其加密\")]),_c('li',[_vm._v(\"服务端用私钥进行解密，得到了客户端创建得随机数\")]),_c('li',[_vm._v(\"双方使用密钥对信息进行对称加密后通讯\")])]),_c('h3',[_vm._v(\"CA认证\")]),_c('p',[_vm._v(\"服务端希望使用HTTPS，生成一对密钥对，发送请求让CA机构签名\\nCA机构校验过后，用自己的私钥签署服务端的密钥对\\nCA机构会把公钥发送给客户端浏览器，客户端在接收到服务端的证书的时候，就可以用CA发的公钥解密，验证服务端的证书是否有CA的签名\")]),_c('h3',[_vm._v(\"自签认证\")]),_c('p',[_vm._v(\"通常当应用发布到模拟环境下，可通过自签认证进行两个应用的HTTPS通讯。服务端生成2对密钥对，其中1对密钥对C用于对另一对A进行签名，密钥对A就是应用A的服务端的密钥对，而C就是作为\"),_c('em',[_vm._v(\"认证机构\")]),_vm._v(\"的密钥对。把C的公钥发送给应用B，当应用B向应用A发送请求，应用A向应用B发送C签署的证书，应用B用C发来的公钥对证书进行解密，确认是由C签署后，应用A和B就可以进行HTTPS通讯。\")])])}]\n\nexport { render, staticRenderFns }","import { render, staticRenderFns } from \"./290420-how-https-works.md?vue&type=template&id=c8b4c0c6&\"\nvar script = {}\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}