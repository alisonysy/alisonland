(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0d5c2a"],{7050:function(_,e,v){"use strict";v.r(e);var n=function(){var _=this,e=_.$createElement;_._self._c;return _._m(0)},l=[function(){var _=this,e=_.$createElement,v=_._self._c||e;return v("section",[v("h2",[_._v("HTTPS工作原理")]),v("p",[_._v("HTTP是明文传输，容易被监听(eavesdropping)、被篡改(tampering)和被冒充(pretending)，而HTTPS能够：")]),v("ol",[v("li",[_._v("所有信息都是"),v("em",[_._v("加密")]),_._v("传播，第三方无法窃听")]),v("li",[_._v("具有"),v("em",[_._v("校验机制")]),_._v("，一旦被篡改，通信双方会发现")]),v("li",[_._v("配备"),v("em",[_._v("身份证书")]),_._v("，防止身份被冒充")])]),v("h3",[_._v("流程")]),v("ol",[v("li",[_._v("客户端发出资源请求")]),v("li",[_._v("服务端返回有CA签名的证书，里面包含服务器生成的公钥")]),v("li",[_._v("客户端有CA的公钥，利用CA的公钥验证服务器返回的证书是否是CA签名过的")]),v("li",[_._v("确认是CA签名后，客户端创建一串随机数作为密钥，然后用服务端传来的公钥对其加密")]),v("li",[_._v("服务端用私钥进行解密，得到了客户端创建得随机数")]),v("li",[_._v("双方使用密钥对信息进行对称加密后通讯")])]),v("h3",[_._v("CA认证")]),v("p",[_._v("服务端希望使用HTTPS，生成一对密钥对，发送请求让CA机构签名\nCA机构校验过后，用自己的私钥签署服务端的密钥对\nCA机构会把公钥发送给客户端浏览器，客户端在接收到服务端的证书的时候，就可以用CA发的公钥解密，验证服务端的证书是否有CA的签名")]),v("h3",[_._v("自签认证")]),v("p",[_._v("通常当应用发布到模拟环境下，可通过自签认证进行两个应用的HTTPS通讯。服务端生成2对密钥对，其中1对密钥对C用于对另一对A进行签名，密钥对A就是应用A的服务端的密钥对，而C就是作为"),v("em",[_._v("认证机构")]),_._v("的密钥对。把C的公钥发送给应用B，当应用B向应用A发送请求，应用A向应用B发送C签署的证书，应用B用C发来的公钥对证书进行解密，确认是由C签署后，应用A和B就可以进行HTTPS通讯。")])])}],i=v("2877"),t={},A=Object(i["a"])(t,n,l,!1,null,null,null);e["default"]=A.exports}}]);
//# sourceMappingURL=chunk-2d0d5c2a.b84c0ee8.js.map