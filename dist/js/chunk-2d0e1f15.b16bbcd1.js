(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0e1f15"],{"7d1c":function(_,v,e){"use strict";e.r(v);var r=function(){var _=this,v=_.$createElement;_._self._c;return _._m(0)},t=[function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("section",[e("h2",[_._v("树结构")]),e("div",{staticClass:"postConcepts"},[_._v("术语")]),_._v("：\n"),e("ul",[e("li",[_._v("一个树结构是由一系列称为节点(nodes)的实体构成，节点由"),e("em",[_._v("边")]),_._v("(edges)连接")]),e("li",[_._v("每个节点包含值，每个节点可能有或没有子节点")]),e("li",[_._v("第一个节点称为"),e("em",[_._v("根节点")]),_._v("(root)，树结构最后且没有子节点的节点称为"),e("em",[_._v("叶子节点")]),_._v("(leaves)")]),e("li",[_._v("树的"),e("strong",[_._v("高度")]),_._v("是根节点"),e("em",[_._v("到叶子节点")]),_._v("所有路径中"),e("strong",[_._v("最长")]),_._v("的路径")]),e("li",[_._v("节点的"),e("strong",[_._v("深度")]),_._v("是该节点到根节点的路径")])]),e("p",[_._v("二叉树一个重要的特性是：")]),e("blockquote",[e("p",[_._v("一个节点的值比该节点的"),e("strong",[_._v("左")]),_._v("子节点(及其后代)的值要"),e("strong",[_._v("大")]),_._v("，但比其"),e("strong",[_._v("右")]),_._v("子节点(及其后代)的值要"),e("strong",[_._v("小")])])]),e("h3",[_._v("创建二叉树和插入节点")]),e("p",[_._v("当创建二叉树时，遵循以下的步骤：")]),e("ol",[e("li",[_._v("新节点的值"),e("em",[_._v("大于")]),_._v("或"),e("em",[_._v("小于")]),_._v("当前节点？")]),e("li",[_._v("若新节点值"),e("em",[_._v("大于")]),_._v("当前节点值，新节点被分配到右边子树(subtree)，若当前节点没有右子节点，则使"),e("code",{pre:!0},[_._v("currentNode.right_child = newNode")]),_._v("；若当前节点已有右子节点，则把右子节点移为当前节点，重新进行步骤1")]),e("li",[_._v("若新节点值"),e("em",[_._v("小于")]),_._v("当前节点值，新节点被分配到左边子树(subtree)，若当前节点没有左子节点，则使"),e("code",{pre:!0},[_._v("currentNode.left_child = newNode")]),_._v("；若当前节点已有左子节点，则把左子节点移为当前节点，重新进行步骤1")]),e("li",[_._v("当新节点的值===当前节点值时，可考虑把新节点插在左边子树")])]),e("h3",[_._v("树的遍历(traversal)")]),e("p",[_._v("2种选择：")]),e("h4",[_._v("深度优先搜索(Depth-First Search - DFS)")]),e("p",[_._v("从根元素开始，逐步遍历完到每个分支，再回到上个父节点，继续该父节点下的另一个分支，有3种深度优先搜索的类型：")]),e("ul",[e("li",[_._v("Pre-order: 从该节点开始，遍历左子节点，再到右子节点")]),e("li",[_._v("In-order: 先遍历左子节点，再到自身(中间)，再到右子节点")]),e("li",[_._v("Post-order: 先遍历左子节点，再到右子节点，再到自身(中间)")])]),e("h4",[_._v("广度优先搜索(Breadth-First Search - BFS)")]),e("p",[_._v("逐层和按深度来遍历树：通过"),e("strong",[_._v("队列")]),_._v("结构来执行BFS搜索：")]),e("ol",[e("li",[_._v("把根节点加入队列")]),e("li",[_._v("队列非空时，遍历")]),e("li",[_._v("获取队列中的第一个节点，打印")]),e("li",[_._v("把这个节点的子节点加入队列中，重复2,3,4")])]),e("h3",[_._v("移除节点和重排树")]),e("p",[_._v("3种情况：")]),e("h4",[_._v("该节点为叶子节点(leaf node)")]),e("p",[_._v("直接删除，无需重新整理树结构")]),e("h4",[_._v("该节点有且只有一个子节点")]),e("p",[_._v("此时需要使该节点的"),e("em",[_._v("父")]),_._v("节点指向该节点的"),e("em",[_._v("子")]),_._v("节点")]),e("h4",[_._v("该节点有2个子节点")]),e("p",[_._v("需要从该节点的右子节点(及其后代)开始，找到该节点右边子树所有节点中的"),e("strong",[_._v("最小值")]),_._v("的子节点，把它代替要移除的节点")])])}],l=e("2877"),o={},n=Object(l["a"])(o,r,t,!1,null,null,null);v["default"]=n.exports}}]);
//# sourceMappingURL=chunk-2d0e1f15.b16bbcd1.js.map